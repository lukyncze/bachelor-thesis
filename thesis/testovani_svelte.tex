\subsubsection{Svelte}

\begin{flushleft}
  \textbf{Instalace projektu}
\end{flushleft}

\begin{flushleft}
  \textbf{Správa stavů, předávání vlastností}
\end{flushleft}

Prvním krokem k vytvoření jednoduchého čítače bude definice komponenty Counter s reaktivním stavem count.

Dále vytvoříme komponentu Button z důvodu dodržování principu DRY a efektivnějšímu znovupoužití kódu v budoucnu.
Komponenta bude přijímat vlastnosti className a onClick. ClassName rozšíří CSS třídy tlačítka a onClick bude obsahovat obslužnou funkci, která se zavolá při kliknutí na tlačítko.
Nyní do šablony přidáme tlačítko a předáme mu vlastnosti className a onClick.
Svelte umožňuje zachytit všechny nedefinované vlastnosti do proměnné \$\$restProps. Proměnnou \$\$restProps tedy pomocí spread operátoru předáme tlačítku a tím jej obohatíme o další vlastnosti. 
Obsah tlačítka, který definujeme mezi párovými značkami Button, vykreslíme pomocí komponenty slot.

V Counter komponentě pak v rámci šablony vykreslíme stav count a Button komponenty, kterým předáme příslušné vlastnosti. 
Pro aktualizaci stavu count použijeme obslužné funkce, v nichž přímo modifikujeme count.

\begin{flushleft}
  \textbf{Interakce v uživatelském prostředí}
\end{flushleft}

V této sekci implementujeme rozbalovací seznam s možnostmi (dropdown). Tvorbu UI komponenty můžeme začít jak vytvořením HTML struktury, tak definicí funkční stránky komponenty. 
My začneme tvorbou šablony, v níž vytvoříme tlačítko a seznam možností. Otevření seznamu možností zajistíme přidáním on:click události na tlačítko. V obslužné funkci pak změníme stav isOpen. 
Seznam možností zobrazíme podmíněně na základě isOpen. Pro vykreslení možností seznamu (dle vstupu options) použijeme blok \#each. 
Pro vybrání konkrétní možnosti použijeme on:click událost, při které v anonymní funkci zavoláme funkci handleOptionClick s aktuální položkou ze seznamu.

Dropdown komponenta bude přijímat vlastnosti options a onChange, případně další vlastnosti pro znovupoužitelnost. Pro každou komponentu také vytvoříme jednoznačný identifikátor, který využijeme při uzavírání seznamu.
Obslužná funkce handleOptionClick zajistí změnu vybrané možnosti, zavření seznamu a provede změnu hodnoty v rodičovské komponentě. 

K uzavření jakéhokoli otevřeného seznamu, při kliknutí mimo tento seznam, předáme kořenovému elementu komponenty dříve vytvořený unikátní identifikátor.
V rámci akce (Svelte action) clickOutsideDropdown budeme naslouchat na události pointerdown v DOM. Obslužná funkce pak zajistí spuštění callbacku v Dropdown komponentě. 
Samotné akci tedy předáme obslužnou funkci handleClickOutsideDropdown, která zavře aktuálně otevřený dropdown.

Třídy CSS v JavaScriptové formě přidáme k elementu pomocí šablonových literálů a JavaScriptové hodnoty.

\begin{flushleft}
  \textbf{Reaktivita, asynchronní operace}
\end{flushleft}

V rámci následující sekce se zaměříme na reaktivitu a asynchronní operace. Naprogramujeme komponentu, která přeloží zadaný text do cílového jazyka. 
Začneme vytvořením komponenty Translator. Komponenta reaktivně (při změně zadaného textu či výstupního jazyka) zavolá API, které vrátí přeložený text. 
V Translator komponentě využijeme vnořené komponenty, které budou sloužit k zadání vstupního textu, výběru jazyka a zobrazení výsledku.

Skrze komponentu LanguageDropdown umožníme uživateli vybrat jazyk, do kterého bude chtít text přeložit. Výstupní jazyk v rodičovské komponentě změníme přes vlastnost onChange.

Pokračujeme implementací komponenty TranslationInput, která umožní zadat vstupní text (inputText) přes textové pole. Aktuální hodnotu formulářového prvku nastavíme pomocí bind:value. 
V rámci rodičovské komponenty použijeme bind, díky čemuž pak reaktivně aktualizujeme inputText v Translator komponentě. K reaktivní změně výšky textového pole použijeme akci autoresizeTextArea. 
Akce přijme element, na kterém se má provést změna výšky. Elementu přidáme listener na událost input. V obslužné funkci následně modifikujeme výšku pole.

V rámci rodičovské komponenty zavoláme API v momentě, kdy dojde ke změně vstupního textu nebo výstupního jazyka. K tomu použijeme reaktivní prohlášení (reactive statement). 
V těle prohlášení zrušíme předchozí časovač a pomocí funkce setTimeout zavoláme funkci handleTranslation. Tímto způsobem předejdeme dotazování serveru ihned po změně nějaké vstupní hodnoty. 
Při zničení komponenty zrušíme časovač a asynchronní požadavky.

Účelem asynchronní funkce handleTranslation pak je odeslání korektního HTTP POST požadavku na server pomocí fetch API. 
Při úspěšné odpovědi aktualizujeme stav s přeloženým textem, v opačném případě nastavíme chybový stav.

Při obdržení odpovědí ze serveru vykreslíme přeložený text uživateli pomocí komponenty TranslationOutput. 
Komponentě předáme výstupní text spolu s dalšími vlastnostmi, na základě kterých v šabloně podmíněně vykreslíme přeložený text, chybu nebo načítání.

\begin{flushleft}
  \textbf{Tvorba formulářů, validace}
\end{flushleft}

\begin{flushleft}
  \textbf{Modularita, použití knihoven}
\end{flushleft}

\begin{flushleft}
  \textbf{Layout aplikace, routování}
\end{flushleft}