\subsubsection{Svelte}

\begin{flushleft}
  \textbf{Instalace projektu}
\end{flushleft}

\begin{flushleft}
  \textbf{Správa stavů, předávání vlastností}
\end{flushleft}

Prvním krokem k vytvoření jednoduchého čítače bude definice komponenty Counter s reaktivním stavem count.

Dále vytvoříme komponentu Button z důvodu dodržování principu DRY a efektivnějšímu znovupoužití kódu v budoucnu.
Komponenta bude přijímat vlastnosti className a onClick. ClassName rozšíří CSS třídy tlačítka a onClick bude obsahovat obslužnou funkci, která se zavolá při kliknutí na tlačítko.
Nyní do šablony přidáme tlačítko a předáme mu vlastnosti className a onClick.
Svelte umožňuje zachytit všechny nedefinované vlastnosti do proměnné \$\$restProps. Proměnnou \$\$restProps tedy pomocí spread operátoru předáme tlačítku a tím jej obohatíme o další vlastnosti. 
Obsah tlačítka, který definujeme mezi párovými značkami Button, vykreslíme pomocí komponenty slot.

V Counter komponentě pak v rámci šablony vykreslíme stav count a Button komponenty, kterým předáme příslušné vlastnosti. 
Pro aktualizaci stavu count použijeme obslužné funkce, v nichž přímo modifikujeme count.

\begin{flushleft}
  \textbf{Interakce v uživatelském prostředí}
\end{flushleft}

V této sekci implementujeme rozbalovací seznam s možnostmi (dropdown). Tvorbu UI komponenty můžeme začít jak vytvořením HTML struktury, tak definicí funkční stránky komponenty. 
My začneme tvorbou šablony, v níž vytvoříme tlačítko a seznam možností. Otevření seznamu možností zajistíme přidáním on:click události na tlačítko. V obslužné funkci pak změníme stav isOpen. 
Seznam možností zobrazíme podmíněně na základě isOpen. Pro vykreslení možností seznamu (dle vstupu options) použijeme blok \#each. 
Pro vybrání konkrétní možnosti použijeme on:click událost, při které v anonymní funkci zavoláme funkci handleOptionClick s aktuální položkou ze seznamu.

Dropdown komponenta bude přijímat vlastnosti options a onChange, případně další vlastnosti pro znovupoužitelnost. Pro každou komponentu také vytvoříme jednoznačný identifikátor, který využijeme při uzavírání seznamu.
Obslužná funkce handleOptionClick zajistí změnu vybrané možnosti, zavření seznamu a provede změnu hodnoty v rodičovské komponentě. 

K uzavření jakéhokoli otevřeného seznamu, při kliknutí mimo tento seznam, předáme kořenovému elementu komponenty dříve vytvořený unikátní identifikátor.
V rámci akce (Svelte action) clickOutsideDropdown budeme naslouchat na události pointerdown v DOM. Obslužná funkce pak zajistí spuštění callbacku v Dropdown komponentě. 
Samotné akci tedy předáme obslužnou funkci handleClickOutsideDropdown, která zavře aktuálně otevřený dropdown.

Třídy CSS v JavaScriptové formě přidáme k elementu pomocí šablonových literálů a JavaScriptové hodnoty.

\begin{flushleft}
  \textbf{Reaktivita, asynchronní operace}
\end{flushleft}

V rámci následující sekce se zaměříme na reaktivitu a asynchronní operace. Naprogramujeme komponentu, která přeloží zadaný text do cílového jazyka. 
Začneme vytvořením komponenty Translator. Komponenta reaktivně (při změně zadaného textu či výstupního jazyka) zavolá API, které vrátí přeložený text. 
V Translator komponentě využijeme vnořené komponenty, které budou sloužit k zadání vstupního textu, výběru jazyka a zobrazení výsledku.

Skrze komponentu LanguageDropdown umožníme uživateli vybrat jazyk, do kterého bude chtít text přeložit. Výstupní jazyk v rodičovské komponentě změníme přes vlastnost onChange.

Pokračujeme implementací komponenty TranslationInput, která umožní zadat vstupní text (inputText) přes textové pole. Aktuální hodnotu formulářového prvku nastavíme pomocí bind:value. 
V rámci rodičovské komponenty použijeme bind, díky čemuž pak reaktivně aktualizujeme inputText v Translator komponentě. K reaktivní změně výšky textového pole použijeme akci autoresizeTextArea. 
Akce přijme element, na kterém se má provést změna výšky. Elementu přidáme listener na událost input. V obslužné funkci následně modifikujeme výšku pole.

V rámci rodičovské komponenty zavoláme API v momentě, kdy dojde ke změně vstupního textu nebo výstupního jazyka. K tomu použijeme reaktivní prohlášení (reactive statement). 
V těle prohlášení zrušíme předchozí časovač a pomocí funkce setTimeout zavoláme funkci handleTranslation. Tímto způsobem předejdeme dotazování serveru ihned po změně nějaké vstupní hodnoty. 
Při zničení komponenty zrušíme časovač a asynchronní požadavky.

Účelem asynchronní funkce handleTranslation pak je odeslání korektního HTTP POST požadavku na server pomocí fetch API. 
Při úspěšné odpovědi aktualizujeme stav s přeloženým textem, v opačném případě nastavíme chybový stav.

Při obdržení odpovědí ze serveru vykreslíme přeložený text uživateli pomocí komponenty TranslationOutput. 
Komponentě předáme výstupní text spolu s dalšími vlastnostmi, na základě kterých v šabloně podmíněně vykreslíme přeložený text, chybu nebo načítání.

\begin{flushleft}
  \textbf{Tvorba formulářů, validace}
\end{flushleft}

Svelte, stejně jako React, nepodporuje pokročilou správu formulářů. Můžeme však využít knihovny třetích stran, jako např. svelte-forms-lib nebo Superforms, které nám umožní lépe spravovat a validovat formuláře. 
V rámci této sekce vytvoříme komponentu pro jednoduchou investiční kalkulaci s využitím knihovny svelte-forms-lib. 
Komponenta InvestForm bude obsahovat formulář pro zadání vstupních hodnot a komponentu FutureValuesInfo pro zobrazení výsledků kalkulace.

Začneme implementací reaktivního formuláře, který bude přijímat počáteční hodnoty (defaultValues) a investFormData sloužící k předání hodnot formuláře do rodičovské komponenty. 
Strukturu formuláře popíšeme v typu InvestFormData. Pomocí funkce createForm z knihovny svelte-forms-lib vytvoříme instanci formuláře, které předáme defaultValues do vlastnosti initialValues. 
V rámci nastavení formuláře také definujeme validační schéma pomocí knihovny yup a onSubmit obslužnou funkci. Knihovnu yup volíme, jelikož je jedinou kompatibilní možností s knihovnou svelte-forms-lib ve verzi 2.0.1. 
% vlastnost validationSchema musí být typu ObjectSchema<any>, který je definován jen a pouze v knihovně yup:
% import type {ObjectSchema} from 'yup';
% validationSchema?: ObjectSchema<any>;
Aby výstupní data (investFormData) odpovídala InvestFormData, musíme transformovat hodnoty formuláře pomocí funkce cast na validačním schématu. V opačném případě budou hodnoty typu string. 
Z createForm následně získáme obslužné funkce handleChange a handleSubmit, dále stavy formuláře form, errors a isValid. Ke stavům formuláře přistupujeme pomocí \$, protože jde o stores observables.

Do šablony přidáme form s on:submit událostí, které předáme handleSubmit. Pokračujeme vytvořením formulářových prvků. 
Jedlotlivé prvky propojíme s reaktivním formulářem pomocí funkce bind:value a události on:change, do které přiřadíme handleChange. Chyby formuláře získáme z errors a vykreslíme je pod formulářovými prvky. 
V neposlední řadě přidáme tlačítko s typem submit, které se postará o odeslání formuláře a zavolání obslužné funkce onSubmit.

Pokračujeme tím, že v rodičovské komponentě pomocí bind získáme aktuální hodnoty formuláře (investFormData). Po změně hodnot formuláře hodnoty transformujeme pomocí funkce futureValuesCalculator. 
Výsledek (futureValues) pak zobrazíme v komponentě FutureValuesInfo. Jedlotlivé výsledky bude zobrazeny v rámci vnořených komponent FutureValueInfo. 
K modifikaci vstupní hodnoty v komponentě FutureValueInfo použijeme reactive statement.

\begin{flushleft}
  \textbf{Modularita, použití knihoven}
\end{flushleft}

Nyní vytvoříme webovou hru, ve které bude úkolem uživatele uhádnout název státu na základě poskytnutých nápovědí. Práci si zlehčíme využitím externích knihoven. 
V rámci hry se postupně odkryje 8 nápovědí, které uživateli pomohou uhádnout název daného státu. Mezi klíčovými prvky bude textové pole pro zadání názvu země a potvrzovací tlačítko. 
Dále ve hře bude seznam zemí, které uživatel hádal a modální okna pro vyhodnocení hry.

Začneme s programováním rodičovské komponenty, jejíž úkolem bude získat země z veřejného API. K tomu využijeme balíček @tanstack/svelte-query a axios. 
Vytvoříme funkci useAllCountries, která vrátí výsledek HTTP dotazu (CreateQueryResult) pomocí funkce createQuery. Argumentem funkce createQuery bude objekt s názvem dotazu (queryKey) a funkce, která vykoná dotaz (queryFn). 
Dotaz na serveru provede asynchronní funkce getAllCountries, v níž využijeme převzatou asynchronní funkci requestHandler a knihovnu axios. Po získání odpovědi ošetříme chyby a vrátíme výsledek.

V rámci rodičovské komponenty dostaneme výsledek dotazu a uložíme jej do proměnné countries. Následně pomocí vlastností isError a data podmíněně vykreslíme jednotlivé komponenty. 
V případě chyby zobrazíme komponentu ErrorAlert. Když úspěšně získáme pole zemí, vykreslíme komponentu CountryGuesser. LoadingSkeleton zobrazíme, pokud se nezobrazí žádná z předchozích komponent.

Komponenta CountryGuesser zobrazí jednotlivé herní prvky a bude vyhodnocovat průběh hry. Začneme definicí stavů a náhodně vybereme náhodnou zemi (randomCountry), kterou uživatel bude hádat. 
V hooku onMount zavoláme funkci polyfillCountryFlagEmojis. Při namontování komponenty tak zajistíme zobrazení ikon vlajek v prohlížečích, které to přímo nepodporují. Prohlížeč uživatele však musí podporovat emojis a webové fonty. 
Funkce polyfillCountryFlagEmojis přidá do hlavičky stránky webový font Twemoji Country Flags. Aby se font použil, přidáme jej do CSS stylů. 
Pokračujeme implementací obslužných funkcí handleEvaluateGuessAndUpdateState, handleSetInitialState, které budou sloužit k aktualizaci stavu hry. V rámci šablony zobrazíme jednotlivé herní prvky a modální okna při výhře či prohře.

V rámci komponenty HintBoxes postupně zobrazíme nápovědy. Podle vstupu randomCountry budeme reaktivně vytvářet pole nápověd, jelikož randomCountry se může změnit. 
V šabloně posléze vykreslíme napovědy pomocí HintBox komponent. HintBox dynamicky vykreslí název a SVG ikonu nápovědy, textovou nápovědu, případně obrázek vlajky státu.

Komponenta CountryGuessInput umožní uživateli zadání názvu země (uživatelova tipu). Začneme šablonou, kde vytvoříme formulářový prvek pro zadání tipu a potvrzovací tlačítko. 
Dále také podmenu textového pole, které zobrazí nejpodobnější země na základě zadaného textu (filtrované země). Přidáme obslužné funkce pro akce a události nad formulářem, které následně doimplementujeme.

V rámci skriptové části získáme, na základě vstupu countries, pole všech zemí bez těch, které uživatel již hádal (countriesWithoutAlreadyGuessed). Dále definujeme a inicializujeme ostatní stavy komponenty. 
Po kliknutí na potvrzovací tlačítko zavoláme funkci handleGuessButtonClick. V tělě funkce zavoláme obslužnou funkci evaluateGuessAndUpdateState, pomocí níž vyhodnotíme stav hry v rodičovské komponentě. 
Následně také funkci handleChangeSelectedGuess, která aktualizuje aktuální tip, filtrované země a uzavře podmenu. Funkce handleInputChange převede tip uživatele do daného formátu, aktualizuje aktuální tip a filtrované země. 
Ovládání textového pole pomocí klávesnice umožní funkce handleKeyDown.

V pomocné funkci updateGuessAndFilteredCountries nejprve získáme filtrované země podle uživatelova tipu. Následně aktualizujeme stavy currentGuess, isValidGuess a filteredCountries. 
Funkce clampSelectedGuessIndex zajistí, aby index vybrané země byl v požadovaném rozmezí (0 až počet filtrovaných zemí). 
K modifikaci stavu selectedGuessIndex použijeme funkci changeSelectedGuessIndex, která index aktualizuje o hodnotu předanou v argumentu. 
Tip uživatele v rámci funkce convertToFormattedGuess převedeme tak, aby začínal velkým písmenem a zbytek řetezce byl složen z malých písmen.

Pro zobrazení všech již hádaných zemí uživatelem vytvoříme komponentu GuessedCountriesList. Ze vstupních vlastností countries, guessedCountries a randomCountry získáme proměnnou enrichedGuessedCountries. 
Jde o uživatelem hádané země s vlajkou a vzdáleností od randomCountry. K převodu využijeme JavaScriptovou funkci z jiného souboru. 
Vzdálenost zemí vypočteme pomocí knihovny calculate-distance-between-coordinates, která exportuje funkci getDistanceBetweenTwoPoints. Proměnnou enrichedGuessedCountries následně vykreslíme v rámci šablony.

Nakonec vytvoříme modální okna, které vykreslíme při výhře nebo prohře. Stavy isWinModalOpen a isLoseModalOpen aktualizujeme v rámci funkce handleEvaluateGuessAndUpdateState v CountryGuesser. 
Na základě těchto stavů podmíněně zobrazíme daná modální okna. Oběma oknům předáme randomCountry a obslužnou funkci handleClose. Do výhernímu modálu také počet potřebných pokusů. 
V jednotlivých komponentách (WinModal, LoseModal) vykreslíme komponentu BaseModal, která bude sloužit jako šablona pro obě okna. Do této komponenty pak předáme titulek, obsah modálu a obslužnou metodu handleClose. 
V šabloně BaseModal vykreslíme základní strukturu modálního okna s dynamickými vlastnostmi.

\begin{flushleft}
  \textbf{Layout aplikace, routování}
\end{flushleft}

Aplikaci rozdělíme do tří částí: hlavičky, patičky a samotného obsahu, v němž vykreslíme jednotlivé komponenty. Uživatel se bude moci přepínat mezi jednotlivými stránkami přes navigační menu. 

Pro routování v aplikaci využijeme knihovnu svelte-spa-router. Nejprve vytvoříme seznam cest aplikace (appRoutes). 
Následně v hlavní komponentě transformujeme appRoutes do požadovaného formátu (typu RouteDefinition) a výsledek uložíme do proměnné routes. 
V šabloně zobrazíme hlavičku, patičku a Router, kterému předáme proměnnou routes. Router následně vykreslí šablonu na základě aktuální URL adresy.

Hlavička zobrazí odkazy na jednotlivé stránky. Architekturu a vzhled navigačního menu převezmeme např. od Flowbite. 
V rámci komponenty Header vypíšeme cesty aplikace pomocí HTML elementu a, na nějž přidáme atribut href. Dále přidáme také akce link a active, které poskytuje svelte-spa-router. 
Akci active předáme objekt, kde přes vlastnosti className a inactiveClassName nastavíme požadovanou CSS třídu podle toho, zda je odkaz aktivní nebo neaktivní. 
K nastavení aria-current použijeme location objekt ze svelte-spa-router, díky kterému získáme aktuální URL.

Stavy isMobileNavOpen a isDarkMode umožní ovládat zobrazení mobilní navigace a barevného režimu. 
Pro uložení informace o preferenci tmavého režimu uživatele použijeme LocalStorage v prohlížeči. Logiku pro přepnutí barevného režimu zavoláme v rámci hooku beforeUpdate. 
Tento hook se spustí po změně lokálního stavu, ale před aktualizací HTML.