\subsubsection{Svelte}

\begin{flushleft}
  \textbf{Instalace projektu}
\end{flushleft}

\begin{flushleft}
  \textbf{Správa stavů, předávání vlastností}
\end{flushleft}

Prvním krokem k vytvoření jednoduchého čítače bude definice komponenty Counter s reaktivním stavem count.

Dále vytvoříme komponentu Button z důvodu dodržování principu DRY a efektivnějšímu znovupoužití kódu v budoucnu.
Komponenta bude přijímat vlastnosti className a onClick. ClassName rozšíří CSS třídy tlačítka a onClick bude obsahovat obslužnou funkci, která se zavolá při kliknutí na tlačítko.
Nyní do šablony přidáme tlačítko a předáme mu vlastnosti className a onClick.
Svelte umožňuje zachytit všechny nedefinované vlastnosti do proměnné \$\$restProps. Proměnnou \$\$restProps tedy pomocí spread operátoru předáme tlačítku a tím jej obohatíme o další vlastnosti. 
Obsah tlačítka, který definujeme mezi párovými značkami Button, vykreslíme pomocí komponenty slot.

V Counter komponentě pak v rámci šablony vykreslíme stav count a Button komponenty, kterým předáme příslušné vlastnosti. 
Pro aktualizaci stavu count použijeme obslužné funkce, v nichž přímo modifikujeme count.

\begin{flushleft}
  \textbf{Interakce v uživatelském prostředí}
\end{flushleft}

V této sekci implementujeme rozbalovací seznam s možnostmi (dropdown). Tvorbu UI komponenty můžeme začít jak vytvořením HTML struktury, tak definicí funkční stránky komponenty. 
My začneme tvorbou šablony, v níž vytvoříme tlačítko a seznam možností. Otevření seznamu možností zajistíme přidáním on:click události na tlačítko. V obslužné funkci pak změníme stav isOpen. 
Seznam možností zobrazíme podmíněně na základě isOpen. Pro vykreslení možností seznamu (dle vstupu options) použijeme blok \#each. 
Pro vybrání konkrétní možnosti použijeme on:click událost, při které v anonymní funkci zavoláme funkci handleOptionClick s aktuální položkou ze seznamu.

Dropdown komponenta bude přijímat vlastnosti options a onChange, případně další vlastnosti pro znovupoužitelnost. Pro každou komponentu také vytvoříme jednoznačný identifikátor, který využijeme při uzavírání seznamu.
Obslužná funkce handleOptionClick zajistí změnu vybrané možnosti, zavření seznamu a provede změnu hodnoty v rodičovské komponentě. 

K uzavření jakéhokoli otevřeného seznamu, při kliknutí mimo tento seznam, předáme kořenovému elementu komponenty dříve vytvořený unikátní identifikátor.
V rámci akce (Svelte action) clickOutsideDropdown budeme naslouchat na události pointerdown v DOM. Obslužná funkce pak zajistí spuštění callbacku v Dropdown komponentě. 
Samotné akci tedy předáme obslužnou funkci handleClickOutsideDropdown, která zavře aktuálně otevřený dropdown.

Třídy CSS v JavaScriptové formě přidáme k elementu pomocí šablonových literálů a JavaScriptové hodnoty.

\begin{flushleft}
  \textbf{Reaktivita, asynchronní operace}
\end{flushleft}

V rámci následující sekce se zaměříme na reaktivitu a asynchronní operace. Naprogramujeme komponentu, která přeloží zadaný text do cílového jazyka. 
Začneme vytvořením komponenty Translator. Komponenta reaktivně (při změně zadaného textu či výstupního jazyka) zavolá API, které vrátí přeložený text. 
V Translator komponentě využijeme vnořené komponenty, které budou sloužit k zadání vstupního textu, výběru jazyka a zobrazení výsledku.

Skrze komponentu LanguageDropdown umožníme uživateli vybrat jazyk, do kterého bude chtít text přeložit. Výstupní jazyk v rodičovské komponentě změníme přes vlastnost onChange.

Pokračujeme implementací komponenty TranslationInput, která umožní zadat vstupní text (inputText) přes textové pole. Aktuální hodnotu formulářového prvku nastavíme pomocí bind:value. 
V rámci rodičovské komponenty použijeme bind, díky čemuž pak reaktivně aktualizujeme inputText v Translator komponentě. K reaktivní změně výšky textového pole použijeme akci autoresizeTextArea. 
Akce přijme element, na kterém se má provést změna výšky. Elementu přidáme listener na událost input. V obslužné funkci následně modifikujeme výšku pole.

V rámci rodičovské komponenty zavoláme API v momentě, kdy dojde ke změně vstupního textu nebo výstupního jazyka. K tomu použijeme reaktivní prohlášení (reactive statement). 
V těle prohlášení zrušíme předchozí časovač a pomocí funkce setTimeout zavoláme funkci handleTranslation. Tímto způsobem předejdeme dotazování serveru ihned po změně nějaké vstupní hodnoty. 
Při zničení komponenty zrušíme časovač a asynchronní požadavky.

Účelem asynchronní funkce handleTranslation pak je odeslání korektního HTTP POST požadavku na server pomocí fetch API. 
Při úspěšné odpovědi aktualizujeme stav s přeloženým textem, v opačném případě nastavíme chybový stav.

Při obdržení odpovědí ze serveru vykreslíme přeložený text uživateli pomocí komponenty TranslationOutput. 
Komponentě předáme výstupní text spolu s dalšími vlastnostmi, na základě kterých v šabloně podmíněně vykreslíme přeložený text, chybu nebo načítání.

\begin{flushleft}
  \textbf{Tvorba formulářů, validace}
\end{flushleft}

Svelte, stejně jako React, nepodporuje pokročilou správu formulářů. Můžeme však využít knihovny třetích stran, jako např. svelte-forms-lib nebo Superforms, které nám umožní lépe spravovat a validovat formuláře. 
V rámci této sekce vytvoříme komponentu pro jednoduchou investiční kalkulaci s využitím knihovny svelte-forms-lib. 
Komponenta InvestForm bude obsahovat formulář pro zadání vstupních hodnot a komponentu FutureValuesInfo pro zobrazení výsledků kalkulace.

Začneme implementací reaktivního formuláře, který bude přijímat počáteční hodnoty (defaultValues) a investFormData sloužící k předání hodnot formuláře do rodičovské komponenty. 
Strukturu formuláře popíšeme v typu InvestFormData. Pomocí funkce createForm z knihovny svelte-forms-lib vytvoříme instanci formuláře, které předáme defaultValues do vlastnosti initialValues. 
V rámci nastavení formuláře také definujeme validační schéma pomocí knihovny yup a onSubmit obslužnou funkci. Knihovnu yup volíme, jelikož je jedinou kompatibilní možností s knihovnou svelte-forms-lib ve verzi 2.0.1. 
% vlastnost validationSchema musí být typu ObjectSchema<any>, který je definován jen a pouze v knihovně yup:
% import type {ObjectSchema} from 'yup';
% validationSchema?: ObjectSchema<any>;
Aby výstupní data (investFormData) odpovídala InvestFormData, musíme transformovat hodnoty formuláře pomocí funkce cast na validačním schématu. V opačném případě budou hodnoty typu string. 
Z createForm následně získáme obslužné funkce handleChange a handleSubmit, dále stavy formuláře form, errors a isValid. Ke stavům formuláře přistupujeme pomocí \$, protože jde o stores observables.

Do šablony přidáme form s on:submit událostí, které předáme handleSubmit. Pokračujeme vytvořením formulářových prvků. 
Jedlotlivé prvky propojíme s reaktivním formulářem pomocí funkce bind:value a události on:change, do které přiřadíme handleChange. Chyby formuláře získáme z errors a vykreslíme je pod formulářovými prvky. 
V neposlední řadě přidáme tlačítko s typem submit, které se postará o odeslání formuláře a zavolání obslužné funkce onSubmit.

Pokračujeme tím, že v rodičovské komponentě pomocí bind získáme aktuální hodnoty formuláře (investFormData). Po změně hodnot formuláře hodnoty transformujeme pomocí funkce futureValuesCalculator. 
Výsledek (futureValues) pak zobrazíme v komponentě FutureValuesInfo. Jedlotlivé výsledky bude zobrazeny v rámci vnořených komponent FutureValueInfo. 
K modifikaci vstupní hodnoty v komponentě FutureValueInfo použijeme reactive statement.

\begin{flushleft}
  \textbf{Modularita, použití knihoven}
\end{flushleft}

\begin{flushleft}
  \textbf{Layout aplikace, routování}
\end{flushleft}

Aplikaci rozdělíme do tří částí: hlavičky, patičky a samotného obsahu, v němž vykreslíme jednotlivé komponenty. Uživatel se bude moci přepínat mezi jednotlivými stránkami přes navigační menu. 

Pro routování v aplikaci využijeme knihovnu svelte-spa-router. Nejprve vytvoříme seznam cest aplikace (appRoutes). 
Následně v hlavní komponentě transformujeme appRoutes do požadovaného formátu (typu RouteDefinition) a výsledek uložíme do proměnné routes. 
V šabloně zobrazíme hlavičku, patičku a Router, kterému předáme proměnnou routes. Router následně vykreslí šablonu na základě aktuální URL adresy.

Hlavička zobrazí odkazy na jednotlivé stránky. Architekturu a vzhled navigačního menu převezmeme např. od Flowbite. 
V rámci komponenty Header vypíšeme cesty aplikace pomocí HTML elementu a, na nějž přidáme atribut href. Dále přidáme také akce link a active, které poskytuje svelte-spa-router. 
Akci active předáme objekt, kde přes vlastnosti className a inactiveClassName nastavíme požadovanou CSS třídu podle toho, zda je odkaz aktivní nebo neaktivní. 
K nastavení aria-current použijeme location objekt ze svelte-spa-router, díky kterému získáme aktuální URL.

Stavy isMobileNavOpen a isDarkMode umožní ovládat zobrazení mobilní navigace a barevného režimu. 
Pro uložení informace o preferenci tmavého režimu uživatele použijeme LocalStorage v prohlížeči. Logiku pro přepnutí barevného režimu zavoláme v rámci hooku beforeUpdate. 
Tento hook se spustí po změně lokálního stavu, ale před aktualizací HTML.