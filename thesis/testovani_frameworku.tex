\section{Testování frameworků}

\begin{citemize}
	\item proč a co je obsahem kapitoly?
\end{citemize}

\subsection{Analýza a návrh testových úloh}

\begin{citemize}
	\item co a proč porovnávám,
	\item v návrhu - jak, jaké testové úlohy?
	\item (dokumentace - možná nahoře, syntax, výkonnostní testy, velikosti bundlů, účel aplikace, rychlost, srozumitelnost, ...)
\end{citemize}

\subsection{Demonstrační aplikace}

V této kapitole srovnáme implementaci stejných funkcionalit ve třech vybraných frameworcích.

\subsubsection{Angular}

\begin{flushleft}
  \textbf{Instalace projektu}
\end{flushleft}

\begin{citemize}
	\item Node.js + NPM
  \item npm init @angular@latest NAZEV\_APLIKACE
  \item \iadresa{https://www.npmjs.com/package/@angular/create}
  \item \iadresa{https://tailwindcss.com/docs/guides/angular}
\end{citemize}

\begin{flushleft}
  \textbf{Správa stavů}
\end{flushleft}

Pro implementaci jednoduchého counteru nejprve vytvoříme counter komponentu. Můžeme začít se strukturou HTML značek pro hlavní komponentu. 
Protože chceme opakovaně použít logiku jednotlivých tlačítek, vytvoříme komponentu counter-button. 
Ta může přijímat například nějaké CSS styly nebo přes EventEmitter (output) posílat informaci o kliknutí na tlačítko směrem nahoru ve stromě komponent. 
Funkci emit() našeho EventEmitteru zavoláme na tlačítku v counter-buttonu právě tehdy, když uživatel klikne na tlačítko -- použijeme listener ve formě (click). 
K propsání textu či jiných elementů nebo komponent mezi párovými tagy <counter-button></counter-button> pak poslouží párový či nepárový element <ng-content />.

Následně v counter komponentě musíme importovat třídu CounterButtonComponent a do všech elementů counter-button předat jejich vstupy a výstupy. 
Námi defikovanovanému outputu buttonClicked předáme v šabloně metodu, která se vykoná po emitu (kliknutí na tlačítko ve vnořené komponentě) a metodu zavoláme pomocí kulatých závorek. 
V rámci counter komponenty pak definujeme stav jako vlastnost count na třídě. Vlastnost pak můžeme modifikovat skrze metody třídy, které voláme v outputu buttonClicked.

\begin{citemize}
	\item šablony + logika komponenty
	\item správa stavů (reaktivita)
	\item body k vypíchnutí: boilerplate frameworku
\end{citemize}

\begin{flushleft}
  \textbf{Interakce v uživatelském prostředí}
\end{flushleft}

Při vytváření jakékoli UI komponenty můžeme začít šablonou, nebo definovat funkční stránku. My začneme s tvorbou šablony. V případě vlastního dropdown samotným tlačítkem a seznamem možností. 
Otevření možností zajístíme tak, že na tlačítko přidáme click listener. Funkčnost pak zajistíme díky modifikaci stavu isOpen, který se provede při volání metody toggleDropdown. 
V rámci této metody je třeba zavolat i event.stopPropagation(). Předejdeme tak potenciální chybě ve formě tzv. event bubblingu -- spuštění událostí na prvcích odlišných od cílového. 

Podmíněně pak můžeme vypsat list možností, které získáme v jednom z inputů. Pro vypsání všech možností použijeme blok @for. 
K vybraní konkrétní možnosti použijeme zase (click) a do obslužné metody pošleme aktuální prvek v poli -- option. 
Metoda handleOptionClick pak zajistí uložení aktuálně vybrané možnosti, zavření dropdownu a vyemitování vybrané možnosti do rodičovské komponenty.

V případě, že máme dropdown otevřen a chceme jej po kliknutí mimo tentýž dropdown bezpečně zavřít, nehledě na počet vykreslených dropdown komponent na stránce, budeme postupovat následovně. 
Pro každou komponentu vytvoříme unikátní vlastnost ve formě ID. To pak dynamicky umístíme na kořenový element dropdownu. 
V komponentě pak budeme naslouchat na události v DOM pomocí dekorátoru @HostListener. 
Dekorátor přijímá DOM událost, na který má poslouchat -- document:pointerdown, případně další argumenty nebo také formu vypublikované události. 
Pod dekorátorem pak definujeme obslužnou metodu, která se volá při emitu specifikované události. V rámci metody pak zajistíme uzavření aktuálně otevřeného dropdownu.

Dropdown pak může mít různé inputy, které povedou k lepší znovupoužitelnosti. Hodnotu inputu (konkrétně např. defaultValue) v komponentě získáme v metodě životního cyklu OnInit. 
Kupříkladu v konstruktoru bychom dostali pouze undefined. Styly ve formě JavaScriptových hodnot do šablony přidáme pomocí ngClass. 
Když těchto hodnot potřebujeme na elementu více, zřetězíme předávané hodnoty pomocí JavaScriptu. Další možnost spočívá ve sloučení požadovaných stylů na úrovni třídy.

\begin{citemize}
	\item body k vypíchnutí: dynamické stylování, logika v template
	\item problémy: zavírání posledně otevřeného dropdownu před otevřením dalšího D.
	\item výhody frameworku: podle bodů nahoře..., tvorba typů ve Svelte
\end{citemize}

\begin{flushleft}
  \textbf{Předávání vlastností, získávání dat z API}
\end{flushleft}

Pro ukázku předávání vlastností a získávání dat z API můžeme vytvořit komponentu, která bude překládat zadaný text do vybraného jazyka. 
Začneme tedy vytvořením rodičovské komponenty, která při změně vlastností (zadaného textu uživatelem a výstupního jazyka) zavolá API, které vrátí přeložený text. 
V rámci této komponenty vytvoříme vnořené komponenty, které budou sloužit k zadání vstupního textu, výběru jazyka a zobrazení výsledku. 

LanguageDropdownComponent umožní uživateli vybrat jazyk, do kterého chce přeložit text. 
Přes EventEmitter aktualizujeme výstupní jazyk v rodičovské komponentě. V rámci obslužné metody handleLanguageChange pak také aktualizujeme hodnotu vlastnosti inputValuesChanges\$.
Tato vlastnost je Subject, speciální typ observable, z knihovny RxJS. Později dovolí na základě změny hodnoty poslat dotaz na server ve správný moment. 
Podobným způsobem poté můžeme registrovat událost změny vstupního textu -- naslouchat na změnu vstupního textu.
% Přidat schéma

Zadání vstupního textu pak může řešit komponenta TranslationInputComponent, která obdobným způsobem aktualizuje hodnotu vstupního textu v rodičovské komponentě. 
Aktuální hodnotu formulářového prvku nastavíme pomocí [ngModel]. Pro naslouchání na změnu hodnoty formulářového prvku zase využijeme (ngModelChange). 
V případě, že potřebujeme aktualizovat výšku textového pole na základě jeho obsahu, můžeme využít vlastní direktivu AutosizeTextAreaDirective. 
V konstruktoru direktivy získáme element, na který přidáme tuto direktivu. Dále budeme potřebovat třídu Renderer2, která umožňuje manipulovat s DOM. 
V direktivě budeme naslouchat na změnu hodnoty textového pole pomocí dekorátoru @HostListener a události input. Následně v rámci obslužné metody zajistíme aktualizaci výšky.
 
Změny hodnoty vlastnosti inputValuesChanges\$ začneme odebírat pomocí subscribe. 
Abychom předešli dotazování serveru ihned po změně hodnoty vlastnosti inputValuesChanges\$, použijeme operátor debounceTime. 
Ten povolí poslat dotaz na server až po uplynutí určité doby od poslední změny, kterou můžeme nastavit. 
Subscribe zavolá věřejnou metodu služby (getTranslation), která vrací přeložený text. 
Nakonec, aby dotazování serveru fungovalo, je třeba metodu setupInputChangeSubscription zavolat v konstruktoru nebo hooku OnInit.

Se službou TranslationService a veřejnou metodou pro vykonání dotazu nám pomůže třída HttpClient. Ta je dostupná přímo v základních modulech Angularu.
Službu HttpClient získáme v konstruktoru, kde ji pomocí klíčového slova private přiřadíme do vlastností třídy. 
Následně na HTTP klientovi zavoláme metodu post vůči API, které vrátí přeložený text ze serveru. 
Pokud úspěšná odpověď ze serveru obsahuje složitější strukturu, ze které potřebujeme získat jen nějakou část, pak s konverzí odpovědi pomůže RxJS operátor map(). 
Metoda getTranslation vrací observable, v translator komponentě proto hodnoty odebíráme pomocí metody subscribe. 

V momentě, kdy obdržíme odpověď ze serveru, zobrazíme přeložený text uživateli. 
K tomu poslouží TranslationOutputComponent, které na vstupu předáme výstupní text spolu s dalšími vstupními vlastnostmi. 
V rámci šablony pak podmíněně vykreslíme přeložený text, chybu nebo načítání. 

Při zarovnání vstupního a výstupního pole v UI si musíme dát pozor na to, že šířku je potřeba nastavit již v prvním potomku div elementu, na kterém nastavíme flexbox. 
Důvod spočívá v tom, že Angular v DOMu vytváří element pro každou komponentu.

\begin{citemize}
	\item předávání vlastností nahoru a dolů
	\item fetchování dat
	\item body k vypíchnutí: velice odlišné reakce na změny, stylování komponent nebo elementů, update textarey (hodnoty), jiné řešení modularity (update stylů textarey)
	\item problémy:
	\item výhody frameworku: předávání vlastností má nej Svelte
\end{citemize}

\begin{flushleft}
  \textbf{Tvorba formulářů}
\end{flushleft}

Angular je flexibilní z pohledu možností tvorby formulářů. My použijeme reaktivní formuláře, jelikož jsou flexibilnější a umožní nám jednodušší reakce na změny prvků.
Vytvoříme komponentu zaměřenou na jednoduché investiční kalkulace. 
Bude obsahovat dvě vnořené komponenty: formulář pro zadání vstupních dat a komponentu výsledku kalkulace, která se zobrazí po potvrzení formuláře.

Začneme s tvorbou reaktivního formuláře. Typ InvestForm popisuje strukturu souvisejících formulářových prvků formuláře. 
Protože prvků budeme mít více, deklarujeme formulářovou skupinu jako vlastnost třídy, ve které následně definujeme samotné formulářové prvky. 
Vlastnost investForm pak umožní přístup k hodnotám formuláře a jeho validaci. Zde narazíme na problém s nenastavením počáteční hodnoty vlastnosti přímo nebo v konstruktoru. 
Můžeme ho vyřešit za pomoci vykřičníku -- řekneme tak TypeScriptu, že obsah proměnné je nenulový. Další možností je vypnout pravidlo strictPropertyInitialization v souboru tsconfig.json.

Hodnotu vlastnosti investForm nastavíme pomocí metody initializeInvestForm v rámci OnInit hooku. 
Tento postup zvolíme, protože chceme nastavovat počáteční hodnoty formuláře na základě vstupní vlastnosti defaultValues.
Důvodem je, že hodnoty vstupních vlastností jsou v komponentě dostupné nejdříve v rámci hooku OnInit.

Metoda initializeInvestForm vrátí instanci třídy FormGroup, kterou vytvoříme pomocí třídy FormBuilder ze základního balíčku @angular/forms. 
Argumentem pro metodu group pak je objekt, který popisuje strukturu formuláře. 
Vlastnosti objektu budou klíče formulářových prvků a jejich hodnoty pole, kde první prvek bude počáteční hodnota a druhý prvek pole validátorů.

V šabloně následně propojíme formulářovou skupinu s formulářem. K tomu poslouží direktiva [formGroup] a její hodnotu nastavíme na vlastnost investForm. 
V rámci formuláře pak vytvoříme formulářové prvky, které propojíme direktivou formControlName. Hodnota pak musí odpovídat klíči prvku ve formulářové skupině. 
Pro zajištění efektivní obsluhy chyb formuláře můžeme využít getter metody, které vrátí konkrétní formulářový prvek.

Dále vytvoříme tlačítko s typem submit, přes které uživatel formulář potvrdí. Na form značku přidáme (ngSubmit), který vyemituje událost při potvrzení formuláře. 
Obslužná metoda pak prostřednictvím výstupové vlastnosti publikuje aktuální hodnotu reaktivního formuláře do rodičovské komponenty.

V rámci rodičovské komponenty tedy vykreslíme samotný formulář a při jakémkoli potvrzení formuláře získáme aktuální hodnoty z formuláře díky outputu. 
Hodnoty formuláře pak dostaneme v obslužné metodě handleFormChanged. Pomocí služby FutureValuesCalculatorService tyto hodnoty transformujeme do požadovaného formátu. 
Výsledek uložíme do vlastnosti futureValues. 

Když jsou hodnoty vypočteny, vykreslíme je na stránce prostřednictvím komponent future-values-info a future-value-info. 
První z komponent slouží k rozložení výsledků do požadovaného formátu a vytvoření komponent pro jednotlivé výsledky. 
Komponenta future-value-info pak přijímá vstupní vlastnost, kterou v šabloně před vykreslením v DOM přetransformujeme díky rouře (LocalizedNumberPipe). 
Stejného výsledku bychom mohli dosáhnout i přes metodu na třídě. Tento přístup Angular nedoporučuje, jelikož metody se v rámci šablony spouští opakovaně a mohou způsobit problémy s výkonem. 
Oproti tomu roura umožní lepší znovupoužitelnost a přehlednost.

\begin{flushleft}
  \textbf{Hra hádání země}
\end{flushleft}

Tato aplikace představuje jakousi webovou hru, cílem uživatele je uhádnout název státu na základě poskytnutých nápovědí. 
V samotné hře najdeme až 8 nápověd, které se postupně zobrazují. Dále textové pole, přes které uživatel zadává názvy hádaných zemí a tlačítko pro potvrzení. 
Součástí je také seznam již zadaných hádaných zemí a modální okna sloužící k vyhodnocení hry.

Začneme s implementací rodičovské komponenty, jež bude získávat data o všech zemích světa z veřejného API. 
Další zodpovědností této komponenty bude vykreslování odpovídajících stavů při získávání dat -- stav načítání, úspěšné získání dat a chyba při získávání dat. 
Vytvoříme službu CountryService, díky které budeme moci získávat data o zemích. Konkrétně k tomu využijeme metodu getAllCountries, která vrátí observable pole všech zemí. 
Výsledek registrace služby a přímé zavolání metody getAllCountries uložíme do vlastnosti třídy. V šabloně posléze potřebujeme odebírat hodnotu z observable. 
Práci v šabloně výrazně ulehčí knihovna ngx-load-with. Tato knihovna poskytuje integrovanou podporu načítání a zpracování chyb. 
To programátorovi umožní využívat předdefinované šablony pro dané stavy bez nutnosti další implementace. Navíc se programátor nemusí starat o zrušení odběru observable.

V rámci komponenty country-guesser budeme implementovat klíčové herní prvky, komponenta také bude vyhodnocovat průběh hry. 
Definujeme tedy vlastnosti třídy, které budou reprezentovat stav a průběh hry. V hooku OnInit získáme náhodou zemi (zemi pro uhádnutí). 
Dále zde zavoláme veřejnou metodu usePolyfill na službě CountryFlagPolyfillService, která zajistí podporu zobrazení ikon vlajek v prohlížečích, které to přímo nepodporují.
Do komponenty také přidáme obslužné metody handleEvaluateGuessAndUpdateState a handleSetInitialState, ve kterých implementujeme logiku hry. 
V šabloně následně vykreslíme UI komponenty hry a podmíněně modální okna přři výhře či prohře.

Služba CountryFlagPolyfillService, jak již bylo popsáno výše, nám dopomůže s podporou zobrazení ikon vlajek v prohlížečích, které nemají podporu zobrazení vlajek. 
Pokud prohlížeč uživatele podporuje emojis a webové fonty, zavoláním funkce polyfillCountryFlagEmojis přes metodu usePolyfill knihovna přidá webové fonty do HTML hlavičky.
Aby se programticky přidaný webový font použil, nesmíme zapomenout také nastavit font-family v rámci CSS stylů. 

HintBoxesComponent postupně vykreslí nápovědy. Při jakékoli změně vstupních vlastností vytvoříme pole nápověd pomocí vlastnosti randomCountry. 
V šabloně iterujeme přes pole nápověd a vykreslíme jednotlivé nápovědy. Vlastnost hintEnabled nastavíme pomocí indexu a vstupní vlastnosti hintsEnabledCount. 
Samotný hint-box pak dynamicky vykreslí název a SVG ikonu nápovědy, textovou nápovědu, případně obrázek vlajky státu.

Pokračujeme komponentou country-guess-input, která uživateli umožní zadat svůj tip. 
Začneme šablonou, kde vytvoříme formulářový prvek pro zadání názvu země, potvrzovací tlačítko. 
Dále podmenu textového pole, které zobrazí nejpodobnější země na základě zadaného textu -- filtrované země a chybové hlášky. 
Můžeme rovnou i přidat obslužné metody pro akce a události nad formulářem, které následně postupně doimplementujeme.

V třídě CountryGuessInputComponent při změně vstupních vlastností (v hooku OnChanges) aktualizujeme vlastnost countriesWithoutAlreadyGuessed a filteredCountries. 
V případě první vlastnosti jde o pole všech zemí bez těch, které uživatel již hádal. Druhá vlastnost poté představuje pole počátečních 8 prvků vlastnosti countriesWithoutAlreadyGuessed. 
Metoda handleGuessButtonClick zavolá obslužnou metodu rodičovské komponenty, která vyhodnotí tip a aktualizuje stav hry. 
Aktualizujeme také hodnoty aktuálního tipu, filtrovaných zemí a uzavřeme podmenu, k čemuž slouží metoda handleChangeSelectedGuess volaná i napřímo z šablony. 
Tělo metody handleInputChange převede uživatelům tip do správného formátu a pomocí převedené hodnoty aktualizuje aktuální tip spolu s filtrovanými zeměmi.
Metoda handleKeyDown se postará o interakce s podmenu pomocí klávesnice. Skrze šipky nahoru a dolů povolíme uživateli vybrat hádanou zemi. 
Enter umožní změnu aktuálního tipu názvu země na právě tu, kterou uživatel označil v podmenu. Escape poslouží k uzavření podmenu.

Pomocná metoda updateGuessAndFilteredCountries pak modifikuje vlastnost currentGuess. 
Následně pomocí metody getFilteredCountries získá aktuálně filtrované země na základě uživatelova tipu. 
Dále nastaví vlastnost isValidGuess, která určuje, zda je uživatelův tip validní (taková země existuje). 
V neposlední řadě se metoda stará i o aktualizaci vlastnosti selectedGuessIndex, jež určuje, která země je vybraná v podmenu. 
K tomu slouží metoda clampSelectedGuessIndex, která index udrží v požadovaném rozmezí (0 až počet filtrovaných zemí).
Metoda getFilteredCountries získává filtrované země na základě vlastnosti currentGuess. 
Pomocná metoda changeSelectedGuessIndex aktualizuje vlastnost selectedGuessIndex o hodnotu předanou v argumentu. 
K převodu tipu uživatele slouží pomocná metoda convertToFormattedGuess. Metoda zajistí, aby tip začínal velkým písmenem a zbytek řetezce byl složen z malých písmen.

Ke zobrazení všech již hádaných zemí uživatelem implementujeme komponentu guessed-countries-list. 
Ze vstupních vlastností countries, guessedCountries a randomCountry pomocí služby EnrichGuessedCountriesService získáme pole již hádaných zemí s jejich vlajkou a vzdáleností od hádané země.
Služba EnrichGuessedCountriesService ke každé hádané zemi přidá vlajku z pole všech zemí a vypočte vzdálenost od hádané země. 
Pro vypočtení vzdálenosti použijeme metodu getDistanceBetweenTwoPoints a vlastnost latlng, kterou získáme z API při získávání všech zemí.
Hodnotu vlastnosti enrichedGuessedCountries aktualizujeme v rámci hooku OnChanges. Jednotlivé hádané země následně vykreslíme v šabloně.

Pokračujeme implementací modálních oken, které se zobrazí při výhře či prohře. 
Vlastnosti isWinModalOpen a isLoseModalOpen, určující, zda se mají okna zobrazit, bychom již měli aktualizovat v rámci metody handleEvaluateGuessAndUpdateState v CountryGuesserComponent. 
Oběma modálním oknům předáme vlastnost randomCountry a output handleClose v podobě obslužné události, která se vyvolá při zavření modálního okna. 
Výhernímu modálu také vlastnost totalGuessesNeeded, jíž využijeme v obsahu okna. 
Obě modální okna budou velice podobné, a proto je vhodné vytvořit komponentu base-modal, která bude sloužit jako šablona pro obě okna. 
BaseModalComponent bude přijímat titulek, obsah modálního okna a handleClose jako výstupní vlastnost. 
Šablona base-modal pak vykreslí základní strukturu modálního okna, s dynamicky nastaveným titulkem, obsahem a obslužnou metodou volanou při zavření modálního okna.

\begin{flushleft}
  \textbf{Layout a routování}
\end{flushleft}

Demonstrační aplikace bude složena z hlavičky, patičky a samotného obsahu, v nemž se vykreslí jednotlivé komponenty. 
Mezi jednotlivými stránkami se uživatel bude moct přepínat pomocí navigačního menu.

K routování mezi jednotlivými stránkami využijeme modul Router přímo od Angularu. Nejprve vytvoříme cesty pro jednotlivé stránky v souboru app.routes.ts. 
Cesty nakonfigurujeme podle předpisu Routes a pole cest exportujeme. Následně tyto cesty aplikace poskytneme routeru v rámci app.config.ts. 

Pokračujeme vytvořením požadované struktury stránek v AppComponent. Šablona bude obsahovat hlavičku, patičku a obsah, který vykreslíme pomocí elementu router-outlet. 

V rámci komponenty hlavičky pak vytvoříme navigační menu, které bude obsahovat odkazy na jednotlivé stránky. 
Můžeme se inspirovat například architekturou a vzhledem navigačního menu Flowbite. 
Pokračujeme vypsáním všech cest aplikace, s čímž nám pomohou direktivy routerLink, routerLinkActive, routerLinkActiveOptions a reference \#link. 
Do routerLink předáme cestu a routerLinkActive umožní naslouchání na aktuální cestu, kde se nacházíme. Direktiva routerLinkActiveOptions pak přepíše výchozí nastavení routerLinkActive.
Reference \#link nám umožní získat informaci o tom, zda je odkaz aktivní. To využijeme při podmíněném nastavení správných CSS tříd.

Přepínání barevného režimu, otevírání a zavírání mobilní navigace implementujeme pomocí obslužným metod a vlastností třídy. 
Informaci o tom, zda má uživatel zapnutý tmavý režim ukládáme do LocalStorage v prohlížeči. 
Při kliknutí na tlačítko pro přepnutí režimu zavoláme metodu, která změní hodnotu vlastnosti a uloží ji do LocalStorage.

\subsubsection{React}

\begin{flushleft}
  \textbf{Instalace projektu}
\end{flushleft}

\begin{flushleft}
  \textbf{Správa stavů}
\end{flushleft}

\begin{flushleft}
  \textbf{Interakce v uživatelském prostředí}
\end{flushleft}

\begin{flushleft}
  \textbf{Předávání vlastností, získávání dat z API}
\end{flushleft}


\subsubsection{Svelte}

\begin{flushleft}
  \textbf{Instalace projektu}
\end{flushleft}

\begin{flushleft}
  \textbf{Správa stavů}
\end{flushleft}

\begin{flushleft}
  \textbf{Interakce v uživatelském prostředí}
\end{flushleft}

\begin{flushleft}
  \textbf{Předávání vlastností, získávání dat z API}
\end{flushleft}


\subsection{Testování aplikací a výsledky}

\begin{citemize}
	\item výsledky a průběh z 3.1
\end{citemize}

